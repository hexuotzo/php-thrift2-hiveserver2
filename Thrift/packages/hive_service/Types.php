<?php

/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';


final class TProtocolVersion {
  const HIVE_CLI_SERVICE_PROTOCOL_V1 = 0;
  const HIVE_CLI_SERVICE_PROTOCOL_V2 = 1;
  const HIVE_CLI_SERVICE_PROTOCOL_V3 = 2;
  const HIVE_CLI_SERVICE_PROTOCOL_V4 = 3;
  static public $__names = array(
    0 => 'HIVE_CLI_SERVICE_PROTOCOL_V1',
    1 => 'HIVE_CLI_SERVICE_PROTOCOL_V2',
    2 => 'HIVE_CLI_SERVICE_PROTOCOL_V3',
    3 => 'HIVE_CLI_SERVICE_PROTOCOL_V4',
  );
}

final class TTypeId {
  const BOOLEAN_TYPE = 0;
  const TINYINT_TYPE = 1;
  const SMALLINT_TYPE = 2;
  const INT_TYPE = 3;
  const BIGINT_TYPE = 4;
  const FLOAT_TYPE = 5;
  const DOUBLE_TYPE = 6;
  const STRING_TYPE = 7;
  const TIMESTAMP_TYPE = 8;
  const BINARY_TYPE = 9;
  const ARRAY_TYPE = 10;
  const MAP_TYPE = 11;
  const STRUCT_TYPE = 12;
  const UNION_TYPE = 13;
  const USER_DEFINED_TYPE = 14;
  const DECIMAL_TYPE = 15;
  static public $__names = array(
    0 => 'BOOLEAN_TYPE',
    1 => 'TINYINT_TYPE',
    2 => 'SMALLINT_TYPE',
    3 => 'INT_TYPE',
    4 => 'BIGINT_TYPE',
    5 => 'FLOAT_TYPE',
    6 => 'DOUBLE_TYPE',
    7 => 'STRING_TYPE',
    8 => 'TIMESTAMP_TYPE',
    9 => 'BINARY_TYPE',
    10 => 'ARRAY_TYPE',
    11 => 'MAP_TYPE',
    12 => 'STRUCT_TYPE',
    13 => 'UNION_TYPE',
    14 => 'USER_DEFINED_TYPE',
    15 => 'DECIMAL_TYPE',
  );
}

final class TStatusCode {
  const SUCCESS_STATUS = 0;
  const SUCCESS_WITH_INFO_STATUS = 1;
  const STILL_EXECUTING_STATUS = 2;
  const ERROR_STATUS = 3;
  const INVALID_HANDLE_STATUS = 4;
  static public $__names = array(
    0 => 'SUCCESS_STATUS',
    1 => 'SUCCESS_WITH_INFO_STATUS',
    2 => 'STILL_EXECUTING_STATUS',
    3 => 'ERROR_STATUS',
    4 => 'INVALID_HANDLE_STATUS',
  );
}

final class TOperationState {
  const INITIALIZED_STATE = 0;
  const RUNNING_STATE = 1;
  const FINISHED_STATE = 2;
  const CANCELED_STATE = 3;
  const CLOSED_STATE = 4;
  const ERROR_STATE = 5;
  const UKNOWN_STATE = 6;
  static public $__names = array(
    0 => 'INITIALIZED_STATE',
    1 => 'RUNNING_STATE',
    2 => 'FINISHED_STATE',
    3 => 'CANCELED_STATE',
    4 => 'CLOSED_STATE',
    5 => 'ERROR_STATE',
    6 => 'UKNOWN_STATE',
  );
}

final class TOperationType {
  const EXECUTE_STATEMENT = 0;
  const GET_TYPE_INFO = 1;
  const GET_CATALOGS = 2;
  const GET_SCHEMAS = 3;
  const GET_TABLES = 4;
  const GET_TABLE_TYPES = 5;
  const GET_COLUMNS = 6;
  const GET_FUNCTIONS = 7;
  const UNKNOWN = 8;
  static public $__names = array(
    0 => 'EXECUTE_STATEMENT',
    1 => 'GET_TYPE_INFO',
    2 => 'GET_CATALOGS',
    3 => 'GET_SCHEMAS',
    4 => 'GET_TABLES',
    5 => 'GET_TABLE_TYPES',
    6 => 'GET_COLUMNS',
    7 => 'GET_FUNCTIONS',
    8 => 'UNKNOWN',
  );
}

final class TGetInfoType {
  const CLI_MAX_DRIVER_CONNECTIONS = 0;
  const CLI_MAX_CONCURRENT_ACTIVITIES = 1;
  const CLI_DATA_SOURCE_NAME = 2;
  const CLI_FETCH_DIRECTION = 8;
  const CLI_SERVER_NAME = 13;
  const CLI_SEARCH_PATTERN_ESCAPE = 14;
  const CLI_DBMS_NAME = 17;
  const CLI_DBMS_VER = 18;
  const CLI_ACCESSIBLE_TABLES = 19;
  const CLI_ACCESSIBLE_PROCEDURES = 20;
  const CLI_CURSOR_COMMIT_BEHAVIOR = 23;
  const CLI_DATA_SOURCE_READ_ONLY = 25;
  const CLI_DEFAULT_TXN_ISOLATION = 26;
  const CLI_IDENTIFIER_CASE = 28;
  const CLI_IDENTIFIER_QUOTE_CHAR = 29;
  const CLI_MAX_COLUMN_NAME_LEN = 30;
  const CLI_MAX_CURSOR_NAME_LEN = 31;
  const CLI_MAX_SCHEMA_NAME_LEN = 32;
  const CLI_MAX_CATALOG_NAME_LEN = 34;
  const CLI_MAX_TABLE_NAME_LEN = 35;
  const CLI_SCROLL_CONCURRENCY = 43;
  const CLI_TXN_CAPABLE = 46;
  const CLI_USER_NAME = 47;
  const CLI_TXN_ISOLATION_OPTION = 72;
  const CLI_INTEGRITY = 73;
  const CLI_GETDATA_EXTENSIONS = 81;
  const CLI_NULL_COLLATION = 85;
  const CLI_ALTER_TABLE = 86;
  const CLI_ORDER_BY_COLUMNS_IN_SELECT = 90;
  const CLI_SPECIAL_CHARACTERS = 94;
  const CLI_MAX_COLUMNS_IN_GROUP_BY = 97;
  const CLI_MAX_COLUMNS_IN_INDEX = 98;
  const CLI_MAX_COLUMNS_IN_ORDER_BY = 99;
  const CLI_MAX_COLUMNS_IN_SELECT = 100;
  const CLI_MAX_COLUMNS_IN_TABLE = 101;
  const CLI_MAX_INDEX_SIZE = 102;
  const CLI_MAX_ROW_SIZE = 104;
  const CLI_MAX_STATEMENT_LEN = 105;
  const CLI_MAX_TABLES_IN_SELECT = 106;
  const CLI_MAX_USER_NAME_LEN = 107;
  const CLI_OJ_CAPABILITIES = 115;
  const CLI_XOPEN_CLI_YEAR = 10000;
  const CLI_CURSOR_SENSITIVITY = 10001;
  const CLI_DESCRIBE_PARAMETER = 10002;
  const CLI_CATALOG_NAME = 10003;
  const CLI_COLLATION_SEQ = 10004;
  const CLI_MAX_IDENTIFIER_LEN = 10005;
  static public $__names = array(
    0 => 'CLI_MAX_DRIVER_CONNECTIONS',
    1 => 'CLI_MAX_CONCURRENT_ACTIVITIES',
    2 => 'CLI_DATA_SOURCE_NAME',
    8 => 'CLI_FETCH_DIRECTION',
    13 => 'CLI_SERVER_NAME',
    14 => 'CLI_SEARCH_PATTERN_ESCAPE',
    17 => 'CLI_DBMS_NAME',
    18 => 'CLI_DBMS_VER',
    19 => 'CLI_ACCESSIBLE_TABLES',
    20 => 'CLI_ACCESSIBLE_PROCEDURES',
    23 => 'CLI_CURSOR_COMMIT_BEHAVIOR',
    25 => 'CLI_DATA_SOURCE_READ_ONLY',
    26 => 'CLI_DEFAULT_TXN_ISOLATION',
    28 => 'CLI_IDENTIFIER_CASE',
    29 => 'CLI_IDENTIFIER_QUOTE_CHAR',
    30 => 'CLI_MAX_COLUMN_NAME_LEN',
    31 => 'CLI_MAX_CURSOR_NAME_LEN',
    32 => 'CLI_MAX_SCHEMA_NAME_LEN',
    34 => 'CLI_MAX_CATALOG_NAME_LEN',
    35 => 'CLI_MAX_TABLE_NAME_LEN',
    43 => 'CLI_SCROLL_CONCURRENCY',
    46 => 'CLI_TXN_CAPABLE',
    47 => 'CLI_USER_NAME',
    72 => 'CLI_TXN_ISOLATION_OPTION',
    73 => 'CLI_INTEGRITY',
    81 => 'CLI_GETDATA_EXTENSIONS',
    85 => 'CLI_NULL_COLLATION',
    86 => 'CLI_ALTER_TABLE',
    90 => 'CLI_ORDER_BY_COLUMNS_IN_SELECT',
    94 => 'CLI_SPECIAL_CHARACTERS',
    97 => 'CLI_MAX_COLUMNS_IN_GROUP_BY',
    98 => 'CLI_MAX_COLUMNS_IN_INDEX',
    99 => 'CLI_MAX_COLUMNS_IN_ORDER_BY',
    100 => 'CLI_MAX_COLUMNS_IN_SELECT',
    101 => 'CLI_MAX_COLUMNS_IN_TABLE',
    102 => 'CLI_MAX_INDEX_SIZE',
    104 => 'CLI_MAX_ROW_SIZE',
    105 => 'CLI_MAX_STATEMENT_LEN',
    106 => 'CLI_MAX_TABLES_IN_SELECT',
    107 => 'CLI_MAX_USER_NAME_LEN',
    115 => 'CLI_OJ_CAPABILITIES',
    10000 => 'CLI_XOPEN_CLI_YEAR',
    10001 => 'CLI_CURSOR_SENSITIVITY',
    10002 => 'CLI_DESCRIBE_PARAMETER',
    10003 => 'CLI_CATALOG_NAME',
    10004 => 'CLI_COLLATION_SEQ',
    10005 => 'CLI_MAX_IDENTIFIER_LEN',
  );
}

final class TFetchOrientation {
  const FETCH_NEXT = 0;
  const FETCH_PRIOR = 1;
  const FETCH_RELATIVE = 2;
  const FETCH_ABSOLUTE = 3;
  const FETCH_FIRST = 4;
  const FETCH_LAST = 5;
  static public $__names = array(
    0 => 'FETCH_NEXT',
    1 => 'FETCH_PRIOR',
    2 => 'FETCH_RELATIVE',
    3 => 'FETCH_ABSOLUTE',
    4 => 'FETCH_FIRST',
    5 => 'FETCH_LAST',
  );
}

class TPrimitiveTypeEntry {
  static $_TSPEC;

  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'TPrimitiveTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TPrimitiveTypeEntry');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TArrayTypeEntry {
  static $_TSPEC;

  public $objectTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'objectTypePtr',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['objectTypePtr'])) {
        $this->objectTypePtr = $vals['objectTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TArrayTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->objectTypePtr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TArrayTypeEntry');
    if ($this->objectTypePtr !== null) {
      $xfer += $output->writeFieldBegin('objectTypePtr', TType::I32, 1);
      $xfer += $output->writeI32($this->objectTypePtr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TMapTypeEntry {
  static $_TSPEC;

  public $keyTypePtr = null;
  public $valueTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyTypePtr',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'valueTypePtr',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keyTypePtr'])) {
        $this->keyTypePtr = $vals['keyTypePtr'];
      }
      if (isset($vals['valueTypePtr'])) {
        $this->valueTypePtr = $vals['valueTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TMapTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->keyTypePtr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->valueTypePtr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TMapTypeEntry');
    if ($this->keyTypePtr !== null) {
      $xfer += $output->writeFieldBegin('keyTypePtr', TType::I32, 1);
      $xfer += $output->writeI32($this->keyTypePtr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->valueTypePtr !== null) {
      $xfer += $output->writeFieldBegin('valueTypePtr', TType::I32, 2);
      $xfer += $output->writeI32($this->valueTypePtr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStructTypeEntry {
  static $_TSPEC;

  public $nameToTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nameToTypePtr',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nameToTypePtr'])) {
        $this->nameToTypePtr = $vals['nameToTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TStructTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->nameToTypePtr = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = 0;
              $xfer += $input->readString($key5);
              $xfer += $input->readI32($val6);
              $this->nameToTypePtr[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStructTypeEntry');
    if ($this->nameToTypePtr !== null) {
      if (!is_array($this->nameToTypePtr)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nameToTypePtr', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->nameToTypePtr));
        {
          foreach ($this->nameToTypePtr as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $output->writeI32($viter8);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TUnionTypeEntry {
  static $_TSPEC;

  public $nameToTypePtr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nameToTypePtr',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nameToTypePtr'])) {
        $this->nameToTypePtr = $vals['nameToTypePtr'];
      }
    }
  }

  public function getName() {
    return 'TUnionTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->nameToTypePtr = array();
            $_size9 = 0;
            $_ktype10 = 0;
            $_vtype11 = 0;
            $xfer += $input->readMapBegin($_ktype10, $_vtype11, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $key14 = '';
              $val15 = 0;
              $xfer += $input->readString($key14);
              $xfer += $input->readI32($val15);
              $this->nameToTypePtr[$key14] = $val15;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TUnionTypeEntry');
    if ($this->nameToTypePtr !== null) {
      if (!is_array($this->nameToTypePtr)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nameToTypePtr', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->nameToTypePtr));
        {
          foreach ($this->nameToTypePtr as $kiter16 => $viter17)
          {
            $xfer += $output->writeString($kiter16);
            $xfer += $output->writeI32($viter17);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TUserDefinedTypeEntry {
  static $_TSPEC;

  public $typeClassName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'typeClassName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['typeClassName'])) {
        $this->typeClassName = $vals['typeClassName'];
      }
    }
  }

  public function getName() {
    return 'TUserDefinedTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->typeClassName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TUserDefinedTypeEntry');
    if ($this->typeClassName !== null) {
      $xfer += $output->writeFieldBegin('typeClassName', TType::STRING, 1);
      $xfer += $output->writeString($this->typeClassName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTypeEntry {
  static $_TSPEC;

  public $primitiveEntry = null;
  public $arrayEntry = null;
  public $mapEntry = null;
  public $structEntry = null;
  public $unionEntry = null;
  public $userDefinedTypeEntry = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'primitiveEntry',
          'type' => TType::STRUCT,
          'class' => 'TPrimitiveTypeEntry',
          ),
        2 => array(
          'var' => 'arrayEntry',
          'type' => TType::STRUCT,
          'class' => 'TArrayTypeEntry',
          ),
        3 => array(
          'var' => 'mapEntry',
          'type' => TType::STRUCT,
          'class' => 'TMapTypeEntry',
          ),
        4 => array(
          'var' => 'structEntry',
          'type' => TType::STRUCT,
          'class' => 'TStructTypeEntry',
          ),
        5 => array(
          'var' => 'unionEntry',
          'type' => TType::STRUCT,
          'class' => 'TUnionTypeEntry',
          ),
        6 => array(
          'var' => 'userDefinedTypeEntry',
          'type' => TType::STRUCT,
          'class' => 'TUserDefinedTypeEntry',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['primitiveEntry'])) {
        $this->primitiveEntry = $vals['primitiveEntry'];
      }
      if (isset($vals['arrayEntry'])) {
        $this->arrayEntry = $vals['arrayEntry'];
      }
      if (isset($vals['mapEntry'])) {
        $this->mapEntry = $vals['mapEntry'];
      }
      if (isset($vals['structEntry'])) {
        $this->structEntry = $vals['structEntry'];
      }
      if (isset($vals['unionEntry'])) {
        $this->unionEntry = $vals['unionEntry'];
      }
      if (isset($vals['userDefinedTypeEntry'])) {
        $this->userDefinedTypeEntry = $vals['userDefinedTypeEntry'];
      }
    }
  }

  public function getName() {
    return 'TTypeEntry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->primitiveEntry = new TPrimitiveTypeEntry();
            $xfer += $this->primitiveEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->arrayEntry = new TArrayTypeEntry();
            $xfer += $this->arrayEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->mapEntry = new TMapTypeEntry();
            $xfer += $this->mapEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->structEntry = new TStructTypeEntry();
            $xfer += $this->structEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->unionEntry = new TUnionTypeEntry();
            $xfer += $this->unionEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->userDefinedTypeEntry = new TUserDefinedTypeEntry();
            $xfer += $this->userDefinedTypeEntry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTypeEntry');
    if ($this->primitiveEntry !== null) {
      if (!is_object($this->primitiveEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('primitiveEntry', TType::STRUCT, 1);
      $xfer += $this->primitiveEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->arrayEntry !== null) {
      if (!is_object($this->arrayEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('arrayEntry', TType::STRUCT, 2);
      $xfer += $this->arrayEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mapEntry !== null) {
      if (!is_object($this->mapEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mapEntry', TType::STRUCT, 3);
      $xfer += $this->mapEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->structEntry !== null) {
      if (!is_object($this->structEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('structEntry', TType::STRUCT, 4);
      $xfer += $this->structEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->unionEntry !== null) {
      if (!is_object($this->unionEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('unionEntry', TType::STRUCT, 5);
      $xfer += $this->unionEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userDefinedTypeEntry !== null) {
      if (!is_object($this->userDefinedTypeEntry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userDefinedTypeEntry', TType::STRUCT, 6);
      $xfer += $this->userDefinedTypeEntry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTypeDesc {
  static $_TSPEC;

  public $types = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'types',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TTypeEntry',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['types'])) {
        $this->types = $vals['types'];
      }
    }
  }

  public function getName() {
    return 'TTypeDesc';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->types = array();
            $_size18 = 0;
            $_etype21 = 0;
            $xfer += $input->readListBegin($_etype21, $_size18);
            for ($_i22 = 0; $_i22 < $_size18; ++$_i22)
            {
              $elem23 = null;
              $elem23 = new TTypeEntry();
              $xfer += $elem23->read($input);
              $this->types []= $elem23;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTypeDesc');
    if ($this->types !== null) {
      if (!is_array($this->types)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('types', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->types));
        {
          foreach ($this->types as $iter24)
          {
            $xfer += $iter24->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TColumnDesc {
  static $_TSPEC;

  public $columnName = null;
  public $typeDesc = null;
  public $position = null;
  public $comment = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'columnName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'typeDesc',
          'type' => TType::STRUCT,
          'class' => 'TTypeDesc',
          ),
        3 => array(
          'var' => 'position',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'comment',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['columnName'])) {
        $this->columnName = $vals['columnName'];
      }
      if (isset($vals['typeDesc'])) {
        $this->typeDesc = $vals['typeDesc'];
      }
      if (isset($vals['position'])) {
        $this->position = $vals['position'];
      }
      if (isset($vals['comment'])) {
        $this->comment = $vals['comment'];
      }
    }
  }

  public function getName() {
    return 'TColumnDesc';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->typeDesc = new TTypeDesc();
            $xfer += $this->typeDesc->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->position);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->comment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumnDesc');
    if ($this->columnName !== null) {
      $xfer += $output->writeFieldBegin('columnName', TType::STRING, 1);
      $xfer += $output->writeString($this->columnName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->typeDesc !== null) {
      if (!is_object($this->typeDesc)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('typeDesc', TType::STRUCT, 2);
      $xfer += $this->typeDesc->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->position !== null) {
      $xfer += $output->writeFieldBegin('position', TType::I32, 3);
      $xfer += $output->writeI32($this->position);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comment !== null) {
      $xfer += $output->writeFieldBegin('comment', TType::STRING, 4);
      $xfer += $output->writeString($this->comment);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TTableSchema {
  static $_TSPEC;

  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TColumnDesc',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'TTableSchema';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size25 = 0;
            $_etype28 = 0;
            $xfer += $input->readListBegin($_etype28, $_size25);
            for ($_i29 = 0; $_i29 < $_size25; ++$_i29)
            {
              $elem30 = null;
              $elem30 = new TColumnDesc();
              $xfer += $elem30->read($input);
              $this->columns []= $elem30;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TTableSchema');
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter31)
          {
            $xfer += $iter31->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TBoolValue {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TBoolValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TBoolValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::BOOL, 1);
      $xfer += $output->writeBool($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TByteValue {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::BYTE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TByteValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TByteValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::BYTE, 1);
      $xfer += $output->writeByte($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI16Value {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TI16Value';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI16Value');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I16, 1);
      $xfer += $output->writeI16($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI32Value {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TI32Value';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI32Value');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I32, 1);
      $xfer += $output->writeI32($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TI64Value {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TI64Value';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TI64Value');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I64, 1);
      $xfer += $output->writeI64($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TDoubleValue {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TDoubleValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TDoubleValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::DOUBLE, 1);
      $xfer += $output->writeDouble($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStringValue {
  static $_TSPEC;

  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'TStringValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStringValue');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 1);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TColumn {
  static $_TSPEC;

  public $boolColumn = null;
  public $byteColumn = null;
  public $i16Column = null;
  public $i32Column = null;
  public $i64Column = null;
  public $doubleColumn = null;
  public $stringColumn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'boolColumn',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TBoolValue',
            ),
          ),
        2 => array(
          'var' => 'byteColumn',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TByteValue',
            ),
          ),
        3 => array(
          'var' => 'i16Column',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TI16Value',
            ),
          ),
        4 => array(
          'var' => 'i32Column',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TI32Value',
            ),
          ),
        5 => array(
          'var' => 'i64Column',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TI64Value',
            ),
          ),
        6 => array(
          'var' => 'doubleColumn',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TDoubleValue',
            ),
          ),
        7 => array(
          'var' => 'stringColumn',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TStringValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['boolColumn'])) {
        $this->boolColumn = $vals['boolColumn'];
      }
      if (isset($vals['byteColumn'])) {
        $this->byteColumn = $vals['byteColumn'];
      }
      if (isset($vals['i16Column'])) {
        $this->i16Column = $vals['i16Column'];
      }
      if (isset($vals['i32Column'])) {
        $this->i32Column = $vals['i32Column'];
      }
      if (isset($vals['i64Column'])) {
        $this->i64Column = $vals['i64Column'];
      }
      if (isset($vals['doubleColumn'])) {
        $this->doubleColumn = $vals['doubleColumn'];
      }
      if (isset($vals['stringColumn'])) {
        $this->stringColumn = $vals['stringColumn'];
      }
    }
  }

  public function getName() {
    return 'TColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->boolColumn = array();
            $_size32 = 0;
            $_etype35 = 0;
            $xfer += $input->readListBegin($_etype35, $_size32);
            for ($_i36 = 0; $_i36 < $_size32; ++$_i36)
            {
              $elem37 = null;
              $elem37 = new TBoolValue();
              $xfer += $elem37->read($input);
              $this->boolColumn []= $elem37;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->byteColumn = array();
            $_size38 = 0;
            $_etype41 = 0;
            $xfer += $input->readListBegin($_etype41, $_size38);
            for ($_i42 = 0; $_i42 < $_size38; ++$_i42)
            {
              $elem43 = null;
              $elem43 = new TByteValue();
              $xfer += $elem43->read($input);
              $this->byteColumn []= $elem43;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->i16Column = array();
            $_size44 = 0;
            $_etype47 = 0;
            $xfer += $input->readListBegin($_etype47, $_size44);
            for ($_i48 = 0; $_i48 < $_size44; ++$_i48)
            {
              $elem49 = null;
              $elem49 = new TI16Value();
              $xfer += $elem49->read($input);
              $this->i16Column []= $elem49;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->i32Column = array();
            $_size50 = 0;
            $_etype53 = 0;
            $xfer += $input->readListBegin($_etype53, $_size50);
            for ($_i54 = 0; $_i54 < $_size50; ++$_i54)
            {
              $elem55 = null;
              $elem55 = new TI32Value();
              $xfer += $elem55->read($input);
              $this->i32Column []= $elem55;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->i64Column = array();
            $_size56 = 0;
            $_etype59 = 0;
            $xfer += $input->readListBegin($_etype59, $_size56);
            for ($_i60 = 0; $_i60 < $_size56; ++$_i60)
            {
              $elem61 = null;
              $elem61 = new TI64Value();
              $xfer += $elem61->read($input);
              $this->i64Column []= $elem61;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->doubleColumn = array();
            $_size62 = 0;
            $_etype65 = 0;
            $xfer += $input->readListBegin($_etype65, $_size62);
            for ($_i66 = 0; $_i66 < $_size62; ++$_i66)
            {
              $elem67 = null;
              $elem67 = new TDoubleValue();
              $xfer += $elem67->read($input);
              $this->doubleColumn []= $elem67;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::LST) {
            $this->stringColumn = array();
            $_size68 = 0;
            $_etype71 = 0;
            $xfer += $input->readListBegin($_etype71, $_size68);
            for ($_i72 = 0; $_i72 < $_size68; ++$_i72)
            {
              $elem73 = null;
              $elem73 = new TStringValue();
              $xfer += $elem73->read($input);
              $this->stringColumn []= $elem73;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumn');
    if ($this->boolColumn !== null) {
      if (!is_array($this->boolColumn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('boolColumn', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->boolColumn));
        {
          foreach ($this->boolColumn as $iter74)
          {
            $xfer += $iter74->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byteColumn !== null) {
      if (!is_array($this->byteColumn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('byteColumn', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->byteColumn));
        {
          foreach ($this->byteColumn as $iter75)
          {
            $xfer += $iter75->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i16Column !== null) {
      if (!is_array($this->i16Column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i16Column', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->i16Column));
        {
          foreach ($this->i16Column as $iter76)
          {
            $xfer += $iter76->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32Column !== null) {
      if (!is_array($this->i32Column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i32Column', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->i32Column));
        {
          foreach ($this->i32Column as $iter77)
          {
            $xfer += $iter77->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64Column !== null) {
      if (!is_array($this->i64Column)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i64Column', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->i64Column));
        {
          foreach ($this->i64Column as $iter78)
          {
            $xfer += $iter78->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->doubleColumn !== null) {
      if (!is_array($this->doubleColumn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('doubleColumn', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->doubleColumn));
        {
          foreach ($this->doubleColumn as $iter79)
          {
            $xfer += $iter79->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringColumn !== null) {
      if (!is_array($this->stringColumn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stringColumn', TType::LST, 7);
      {
        $output->writeListBegin(TType::STRUCT, count($this->stringColumn));
        {
          foreach ($this->stringColumn as $iter80)
          {
            $xfer += $iter80->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TColumnValue {
  static $_TSPEC;

  public $boolVal = null;
  public $byteVal = null;
  public $i16Val = null;
  public $i32Val = null;
  public $i64Val = null;
  public $doubleVal = null;
  public $stringVal = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'boolVal',
          'type' => TType::STRUCT,
          'class' => 'TBoolValue',
          ),
        2 => array(
          'var' => 'byteVal',
          'type' => TType::STRUCT,
          'class' => 'TByteValue',
          ),
        3 => array(
          'var' => 'i16Val',
          'type' => TType::STRUCT,
          'class' => 'TI16Value',
          ),
        4 => array(
          'var' => 'i32Val',
          'type' => TType::STRUCT,
          'class' => 'TI32Value',
          ),
        5 => array(
          'var' => 'i64Val',
          'type' => TType::STRUCT,
          'class' => 'TI64Value',
          ),
        6 => array(
          'var' => 'doubleVal',
          'type' => TType::STRUCT,
          'class' => 'TDoubleValue',
          ),
        7 => array(
          'var' => 'stringVal',
          'type' => TType::STRUCT,
          'class' => 'TStringValue',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['boolVal'])) {
        $this->boolVal = $vals['boolVal'];
      }
      if (isset($vals['byteVal'])) {
        $this->byteVal = $vals['byteVal'];
      }
      if (isset($vals['i16Val'])) {
        $this->i16Val = $vals['i16Val'];
      }
      if (isset($vals['i32Val'])) {
        $this->i32Val = $vals['i32Val'];
      }
      if (isset($vals['i64Val'])) {
        $this->i64Val = $vals['i64Val'];
      }
      if (isset($vals['doubleVal'])) {
        $this->doubleVal = $vals['doubleVal'];
      }
      if (isset($vals['stringVal'])) {
        $this->stringVal = $vals['stringVal'];
      }
    }
  }

  public function getName() {
    return 'TColumnValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->boolVal = new TBoolValue();
            $xfer += $this->boolVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->byteVal = new TByteValue();
            $xfer += $this->byteVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->i16Val = new TI16Value();
            $xfer += $this->i16Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->i32Val = new TI32Value();
            $xfer += $this->i32Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->i64Val = new TI64Value();
            $xfer += $this->i64Val->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->doubleVal = new TDoubleValue();
            $xfer += $this->doubleVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->stringVal = new TStringValue();
            $xfer += $this->stringVal->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumnValue');
    if ($this->boolVal !== null) {
      if (!is_object($this->boolVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('boolVal', TType::STRUCT, 1);
      $xfer += $this->boolVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byteVal !== null) {
      if (!is_object($this->byteVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('byteVal', TType::STRUCT, 2);
      $xfer += $this->byteVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i16Val !== null) {
      if (!is_object($this->i16Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i16Val', TType::STRUCT, 3);
      $xfer += $this->i16Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32Val !== null) {
      if (!is_object($this->i32Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i32Val', TType::STRUCT, 4);
      $xfer += $this->i32Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64Val !== null) {
      if (!is_object($this->i64Val)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('i64Val', TType::STRUCT, 5);
      $xfer += $this->i64Val->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->doubleVal !== null) {
      if (!is_object($this->doubleVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('doubleVal', TType::STRUCT, 6);
      $xfer += $this->doubleVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringVal !== null) {
      if (!is_object($this->stringVal)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stringVal', TType::STRUCT, 7);
      $xfer += $this->stringVal->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TRow {
  static $_TSPEC;

  public $colVals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'colVals',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TColumnValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['colVals'])) {
        $this->colVals = $vals['colVals'];
      }
    }
  }

  public function getName() {
    return 'TRow';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->colVals = array();
            $_size81 = 0;
            $_etype84 = 0;
            $xfer += $input->readListBegin($_etype84, $_size81);
            for ($_i85 = 0; $_i85 < $_size81; ++$_i85)
            {
              $elem86 = null;
              $elem86 = new TColumnValue();
              $xfer += $elem86->read($input);
              $this->colVals []= $elem86;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRow');
    if ($this->colVals !== null) {
      if (!is_array($this->colVals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('colVals', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->colVals));
        {
          foreach ($this->colVals as $iter87)
          {
            $xfer += $iter87->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TRowSet {
  static $_TSPEC;

  public $startRowOffset = null;
  public $rows = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'startRowOffset',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'rows',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRow',
            ),
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TColumn',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['startRowOffset'])) {
        $this->startRowOffset = $vals['startRowOffset'];
      }
      if (isset($vals['rows'])) {
        $this->rows = $vals['rows'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'TRowSet';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startRowOffset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rows = array();
            $_size88 = 0;
            $_etype91 = 0;
            $xfer += $input->readListBegin($_etype91, $_size88);
            for ($_i92 = 0; $_i92 < $_size88; ++$_i92)
            {
              $elem93 = null;
              $elem93 = new TRow();
              $xfer += $elem93->read($input);
              $this->rows []= $elem93;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size94 = 0;
            $_etype97 = 0;
            $xfer += $input->readListBegin($_etype97, $_size94);
            for ($_i98 = 0; $_i98 < $_size94; ++$_i98)
            {
              $elem99 = null;
              $elem99 = new TColumn();
              $xfer += $elem99->read($input);
              $this->columns []= $elem99;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRowSet');
    if ($this->startRowOffset !== null) {
      $xfer += $output->writeFieldBegin('startRowOffset', TType::I64, 1);
      $xfer += $output->writeI64($this->startRowOffset);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rows !== null) {
      if (!is_array($this->rows)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rows', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->rows));
        {
          foreach ($this->rows as $iter100)
          {
            $xfer += $iter100->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $iter101)
          {
            $xfer += $iter101->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TStatus {
  static $_TSPEC;

  public $statusCode = null;
  public $infoMessages = null;
  public $sqlState = null;
  public $errorCode = null;
  public $errorMessage = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'statusCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'infoMessages',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'sqlState',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'errorMessage',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['statusCode'])) {
        $this->statusCode = $vals['statusCode'];
      }
      if (isset($vals['infoMessages'])) {
        $this->infoMessages = $vals['infoMessages'];
      }
      if (isset($vals['sqlState'])) {
        $this->sqlState = $vals['sqlState'];
      }
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['errorMessage'])) {
        $this->errorMessage = $vals['errorMessage'];
      }
    }
  }

  public function getName() {
    return 'TStatus';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->statusCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->infoMessages = array();
            $_size102 = 0;
            $_etype105 = 0;
            $xfer += $input->readListBegin($_etype105, $_size102);
            for ($_i106 = 0; $_i106 < $_size102; ++$_i106)
            {
              $elem107 = null;
              $xfer += $input->readString($elem107);
              $this->infoMessages []= $elem107;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sqlState);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TStatus');
    if ($this->statusCode !== null) {
      $xfer += $output->writeFieldBegin('statusCode', TType::I32, 1);
      $xfer += $output->writeI32($this->statusCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->infoMessages !== null) {
      if (!is_array($this->infoMessages)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('infoMessages', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->infoMessages));
        {
          foreach ($this->infoMessages as $iter108)
          {
            $xfer += $output->writeString($iter108);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sqlState !== null) {
      $xfer += $output->writeFieldBegin('sqlState', TType::STRING, 3);
      $xfer += $output->writeString($this->sqlState);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 4);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessage !== null) {
      $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 5);
      $xfer += $output->writeString($this->errorMessage);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class THandleIdentifier {
  static $_TSPEC;

  public $guid = null;
  public $secret = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'guid',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'secret',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['guid'])) {
        $this->guid = $vals['guid'];
      }
      if (isset($vals['secret'])) {
        $this->secret = $vals['secret'];
      }
    }
  }

  public function getName() {
    return 'THandleIdentifier';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->guid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->secret);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('THandleIdentifier');
    if ($this->guid !== null) {
      $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
      $xfer += $output->writeString($this->guid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->secret !== null) {
      $xfer += $output->writeFieldBegin('secret', TType::STRING, 2);
      $xfer += $output->writeString($this->secret);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TSessionHandle {
  static $_TSPEC;

  public $sessionId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionId',
          'type' => TType::STRUCT,
          'class' => 'THandleIdentifier',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionId'])) {
        $this->sessionId = $vals['sessionId'];
      }
    }
  }

  public function getName() {
    return 'TSessionHandle';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionId = new THandleIdentifier();
            $xfer += $this->sessionId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TSessionHandle');
    if ($this->sessionId !== null) {
      if (!is_object($this->sessionId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionId', TType::STRUCT, 1);
      $xfer += $this->sessionId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TOperationHandle {
  static $_TSPEC;

  public $operationId = null;
  public $operationType = null;
  public $hasResultSet = null;
  public $modifiedRowCount = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationId',
          'type' => TType::STRUCT,
          'class' => 'THandleIdentifier',
          ),
        2 => array(
          'var' => 'operationType',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'hasResultSet',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'modifiedRowCount',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationId'])) {
        $this->operationId = $vals['operationId'];
      }
      if (isset($vals['operationType'])) {
        $this->operationType = $vals['operationType'];
      }
      if (isset($vals['hasResultSet'])) {
        $this->hasResultSet = $vals['hasResultSet'];
      }
      if (isset($vals['modifiedRowCount'])) {
        $this->modifiedRowCount = $vals['modifiedRowCount'];
      }
    }
  }

  public function getName() {
    return 'TOperationHandle';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationId = new THandleIdentifier();
            $xfer += $this->operationId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->hasResultSet);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->modifiedRowCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TOperationHandle');
    if ($this->operationId !== null) {
      if (!is_object($this->operationId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationId', TType::STRUCT, 1);
      $xfer += $this->operationId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationType !== null) {
      $xfer += $output->writeFieldBegin('operationType', TType::I32, 2);
      $xfer += $output->writeI32($this->operationType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hasResultSet !== null) {
      $xfer += $output->writeFieldBegin('hasResultSet', TType::BOOL, 3);
      $xfer += $output->writeBool($this->hasResultSet);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->modifiedRowCount !== null) {
      $xfer += $output->writeFieldBegin('modifiedRowCount', TType::DOUBLE, 4);
      $xfer += $output->writeDouble($this->modifiedRowCount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TOpenSessionReq {
  static $_TSPEC;

  public $client_protocol =   0;
  public $username = null;
  public $password = null;
  public $configuration = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'client_protocol',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'username',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'configuration',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['client_protocol'])) {
        $this->client_protocol = $vals['client_protocol'];
      }
      if (isset($vals['username'])) {
        $this->username = $vals['username'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
      if (isset($vals['configuration'])) {
        $this->configuration = $vals['configuration'];
      }
    }
  }

  public function getName() {
    return 'TOpenSessionReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->client_protocol);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->username);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->configuration = array();
            $_size109 = 0;
            $_ktype110 = 0;
            $_vtype111 = 0;
            $xfer += $input->readMapBegin($_ktype110, $_vtype111, $_size109);
            for ($_i113 = 0; $_i113 < $_size109; ++$_i113)
            {
              $key114 = '';
              $val115 = '';
              $xfer += $input->readString($key114);
              $xfer += $input->readString($val115);
              $this->configuration[$key114] = $val115;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TOpenSessionReq');
    if ($this->client_protocol !== null) {
      $xfer += $output->writeFieldBegin('client_protocol', TType::I32, 1);
      $xfer += $output->writeI32($this->client_protocol);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->username !== null) {
      $xfer += $output->writeFieldBegin('username', TType::STRING, 2);
      $xfer += $output->writeString($this->username);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->configuration !== null) {
      if (!is_array($this->configuration)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('configuration', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->configuration));
        {
          foreach ($this->configuration as $kiter116 => $viter117)
          {
            $xfer += $output->writeString($kiter116);
            $xfer += $output->writeString($viter117);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TOpenSessionResp {
  static $_TSPEC;

  public $status = null;
  public $serverProtocolVersion =   0;
  public $sessionHandle = null;
  public $configuration = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'serverProtocolVersion',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        4 => array(
          'var' => 'configuration',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['serverProtocolVersion'])) {
        $this->serverProtocolVersion = $vals['serverProtocolVersion'];
      }
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['configuration'])) {
        $this->configuration = $vals['configuration'];
      }
    }
  }

  public function getName() {
    return 'TOpenSessionResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->serverProtocolVersion);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->configuration = array();
            $_size118 = 0;
            $_ktype119 = 0;
            $_vtype120 = 0;
            $xfer += $input->readMapBegin($_ktype119, $_vtype120, $_size118);
            for ($_i122 = 0; $_i122 < $_size118; ++$_i122)
            {
              $key123 = '';
              $val124 = '';
              $xfer += $input->readString($key123);
              $xfer += $input->readString($val124);
              $this->configuration[$key123] = $val124;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TOpenSessionResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serverProtocolVersion !== null) {
      $xfer += $output->writeFieldBegin('serverProtocolVersion', TType::I32, 2);
      $xfer += $output->writeI32($this->serverProtocolVersion);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 3);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->configuration !== null) {
      if (!is_array($this->configuration)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('configuration', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->configuration));
        {
          foreach ($this->configuration as $kiter125 => $viter126)
          {
            $xfer += $output->writeString($kiter125);
            $xfer += $output->writeString($viter126);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseSessionReq {
  static $_TSPEC;

  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TCloseSessionReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseSessionReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseSessionResp {
  static $_TSPEC;

  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TCloseSessionResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseSessionResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetInfoValue {
  static $_TSPEC;

  public $stringValue = null;
  public $smallIntValue = null;
  public $integerBitmask = null;
  public $integerFlag = null;
  public $binaryValue = null;
  public $lenValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'stringValue',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'smallIntValue',
          'type' => TType::I16,
          ),
        3 => array(
          'var' => 'integerBitmask',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'integerFlag',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'binaryValue',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'lenValue',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['stringValue'])) {
        $this->stringValue = $vals['stringValue'];
      }
      if (isset($vals['smallIntValue'])) {
        $this->smallIntValue = $vals['smallIntValue'];
      }
      if (isset($vals['integerBitmask'])) {
        $this->integerBitmask = $vals['integerBitmask'];
      }
      if (isset($vals['integerFlag'])) {
        $this->integerFlag = $vals['integerFlag'];
      }
      if (isset($vals['binaryValue'])) {
        $this->binaryValue = $vals['binaryValue'];
      }
      if (isset($vals['lenValue'])) {
        $this->lenValue = $vals['lenValue'];
      }
    }
  }

  public function getName() {
    return 'TGetInfoValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stringValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->smallIntValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->integerBitmask);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->integerFlag);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->binaryValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lenValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetInfoValue');
    if ($this->stringValue !== null) {
      $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 1);
      $xfer += $output->writeString($this->stringValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->smallIntValue !== null) {
      $xfer += $output->writeFieldBegin('smallIntValue', TType::I16, 2);
      $xfer += $output->writeI16($this->smallIntValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->integerBitmask !== null) {
      $xfer += $output->writeFieldBegin('integerBitmask', TType::I32, 3);
      $xfer += $output->writeI32($this->integerBitmask);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->integerFlag !== null) {
      $xfer += $output->writeFieldBegin('integerFlag', TType::I32, 4);
      $xfer += $output->writeI32($this->integerFlag);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binaryValue !== null) {
      $xfer += $output->writeFieldBegin('binaryValue', TType::I32, 5);
      $xfer += $output->writeI32($this->binaryValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lenValue !== null) {
      $xfer += $output->writeFieldBegin('lenValue', TType::I64, 6);
      $xfer += $output->writeI64($this->lenValue);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetInfoReq {
  static $_TSPEC;

  public $sessionHandle = null;
  public $infoType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        2 => array(
          'var' => 'infoType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['infoType'])) {
        $this->infoType = $vals['infoType'];
      }
    }
  }

  public function getName() {
    return 'TGetInfoReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->infoType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetInfoReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->infoType !== null) {
      $xfer += $output->writeFieldBegin('infoType', TType::I32, 2);
      $xfer += $output->writeI32($this->infoType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetInfoResp {
  static $_TSPEC;

  public $status = null;
  public $infoValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'infoValue',
          'type' => TType::STRUCT,
          'class' => 'TGetInfoValue',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['infoValue'])) {
        $this->infoValue = $vals['infoValue'];
      }
    }
  }

  public function getName() {
    return 'TGetInfoResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->infoValue = new TGetInfoValue();
            $xfer += $this->infoValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetInfoResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->infoValue !== null) {
      if (!is_object($this->infoValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('infoValue', TType::STRUCT, 2);
      $xfer += $this->infoValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TExecuteStatementReq {
  static $_TSPEC;

  public $sessionHandle = null;
  public $statement = null;
  public $confOverlay = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        2 => array(
          'var' => 'statement',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'confOverlay',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['statement'])) {
        $this->statement = $vals['statement'];
      }
      if (isset($vals['confOverlay'])) {
        $this->confOverlay = $vals['confOverlay'];
      }
    }
  }

  public function getName() {
    return 'TExecuteStatementReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->statement);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->confOverlay = array();
            $_size127 = 0;
            $_ktype128 = 0;
            $_vtype129 = 0;
            $xfer += $input->readMapBegin($_ktype128, $_vtype129, $_size127);
            for ($_i131 = 0; $_i131 < $_size127; ++$_i131)
            {
              $key132 = '';
              $val133 = '';
              $xfer += $input->readString($key132);
              $xfer += $input->readString($val133);
              $this->confOverlay[$key132] = $val133;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TExecuteStatementReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->statement !== null) {
      $xfer += $output->writeFieldBegin('statement', TType::STRING, 2);
      $xfer += $output->writeString($this->statement);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->confOverlay !== null) {
      if (!is_array($this->confOverlay)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('confOverlay', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->confOverlay));
        {
          foreach ($this->confOverlay as $kiter134 => $viter135)
          {
            $xfer += $output->writeString($kiter134);
            $xfer += $output->writeString($viter135);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TExecuteStatementResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TExecuteStatementResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TExecuteStatementResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTypeInfoReq {
  static $_TSPEC;

  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTypeInfoReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTypeInfoReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTypeInfoResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTypeInfoResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTypeInfoResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetCatalogsReq {
  static $_TSPEC;

  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetCatalogsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetCatalogsReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetCatalogsResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetCatalogsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetCatalogsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetSchemasReq {
  static $_TSPEC;

  public $sessionHandle = null;
  public $catalogName = null;
  public $schemaName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
    }
  }

  public function getName() {
    return 'TGetSchemasReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetSchemasReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetSchemasResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetSchemasResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetSchemasResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTablesReq {
  static $_TSPEC;

  public $sessionHandle = null;
  public $catalogName = null;
  public $schemaName = null;
  public $tableName = null;
  public $tableTypes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'tableTypes',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['tableTypes'])) {
        $this->tableTypes = $vals['tableTypes'];
      }
    }
  }

  public function getName() {
    return 'TGetTablesReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->tableTypes = array();
            $_size136 = 0;
            $_etype139 = 0;
            $xfer += $input->readListBegin($_etype139, $_size136);
            for ($_i140 = 0; $_i140 < $_size136; ++$_i140)
            {
              $elem141 = null;
              $xfer += $input->readString($elem141);
              $this->tableTypes []= $elem141;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTablesReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 4);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableTypes !== null) {
      if (!is_array($this->tableTypes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tableTypes', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->tableTypes));
        {
          foreach ($this->tableTypes as $iter142)
          {
            $xfer += $output->writeString($iter142);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTablesResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTablesResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTablesResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTableTypesReq {
  static $_TSPEC;

  public $sessionHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTableTypesReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTableTypesReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetTableTypesResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetTableTypesResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetTableTypesResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetColumnsReq {
  static $_TSPEC;

  public $sessionHandle = null;
  public $catalogName = null;
  public $schemaName = null;
  public $tableName = null;
  public $columnName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'columnName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columnName'])) {
        $this->columnName = $vals['columnName'];
      }
    }
  }

  public function getName() {
    return 'TGetColumnsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetColumnsReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 4);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnName !== null) {
      $xfer += $output->writeFieldBegin('columnName', TType::STRING, 5);
      $xfer += $output->writeString($this->columnName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetColumnsResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetColumnsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetColumnsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetFunctionsReq {
  static $_TSPEC;

  public $sessionHandle = null;
  public $catalogName = null;
  public $schemaName = null;
  public $functionName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sessionHandle',
          'type' => TType::STRUCT,
          'class' => 'TSessionHandle',
          ),
        2 => array(
          'var' => 'catalogName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'functionName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sessionHandle'])) {
        $this->sessionHandle = $vals['sessionHandle'];
      }
      if (isset($vals['catalogName'])) {
        $this->catalogName = $vals['catalogName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['functionName'])) {
        $this->functionName = $vals['functionName'];
      }
    }
  }

  public function getName() {
    return 'TGetFunctionsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->sessionHandle = new TSessionHandle();
            $xfer += $this->sessionHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->catalogName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->functionName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetFunctionsReq');
    if ($this->sessionHandle !== null) {
      if (!is_object($this->sessionHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionHandle', TType::STRUCT, 1);
      $xfer += $this->sessionHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->catalogName !== null) {
      $xfer += $output->writeFieldBegin('catalogName', TType::STRING, 2);
      $xfer += $output->writeString($this->catalogName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 3);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->functionName !== null) {
      $xfer += $output->writeFieldBegin('functionName', TType::STRING, 4);
      $xfer += $output->writeString($this->functionName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetFunctionsResp {
  static $_TSPEC;

  public $status = null;
  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetFunctionsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetFunctionsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 2);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetOperationStatusReq {
  static $_TSPEC;

  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetOperationStatusReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetOperationStatusReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetOperationStatusResp {
  static $_TSPEC;

  public $status = null;
  public $operationState = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'operationState',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['operationState'])) {
        $this->operationState = $vals['operationState'];
      }
    }
  }

  public function getName() {
    return 'TGetOperationStatusResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationState);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetOperationStatusResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationState !== null) {
      $xfer += $output->writeFieldBegin('operationState', TType::I32, 2);
      $xfer += $output->writeI32($this->operationState);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCancelOperationReq {
  static $_TSPEC;

  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TCancelOperationReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCancelOperationReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCancelOperationResp {
  static $_TSPEC;

  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TCancelOperationResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCancelOperationResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseOperationReq {
  static $_TSPEC;

  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TCloseOperationReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseOperationReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TCloseOperationResp {
  static $_TSPEC;

  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'TCloseOperationResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCloseOperationResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetResultSetMetadataReq {
  static $_TSPEC;

  public $operationHandle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
    }
  }

  public function getName() {
    return 'TGetResultSetMetadataReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetResultSetMetadataReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TGetResultSetMetadataResp {
  static $_TSPEC;

  public $status = null;
  public $schema = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => 'TTableSchema',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
    }
  }

  public function getName() {
    return 'TGetResultSetMetadataResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->schema = new TTableSchema();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TGetResultSetMetadataResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 2);
      $xfer += $this->schema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TFetchResultsReq {
  static $_TSPEC;

  public $operationHandle = null;
  public $orientation =   0;
  public $maxRows = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationHandle',
          'type' => TType::STRUCT,
          'class' => 'TOperationHandle',
          ),
        2 => array(
          'var' => 'orientation',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'maxRows',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationHandle'])) {
        $this->operationHandle = $vals['operationHandle'];
      }
      if (isset($vals['orientation'])) {
        $this->orientation = $vals['orientation'];
      }
      if (isset($vals['maxRows'])) {
        $this->maxRows = $vals['maxRows'];
      }
    }
  }

  public function getName() {
    return 'TFetchResultsReq';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationHandle = new TOperationHandle();
            $xfer += $this->operationHandle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->orientation);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TFetchResultsReq');
    if ($this->operationHandle !== null) {
      if (!is_object($this->operationHandle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationHandle', TType::STRUCT, 1);
      $xfer += $this->operationHandle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orientation !== null) {
      $xfer += $output->writeFieldBegin('orientation', TType::I32, 2);
      $xfer += $output->writeI32($this->orientation);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxRows !== null) {
      $xfer += $output->writeFieldBegin('maxRows', TType::I64, 3);
      $xfer += $output->writeI64($this->maxRows);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TFetchResultsResp {
  static $_TSPEC;

  public $status = null;
  public $hasMoreRows = null;
  public $results = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => 'TStatus',
          ),
        2 => array(
          'var' => 'hasMoreRows',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'results',
          'type' => TType::STRUCT,
          'class' => 'TRowSet',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['hasMoreRows'])) {
        $this->hasMoreRows = $vals['hasMoreRows'];
      }
      if (isset($vals['results'])) {
        $this->results = $vals['results'];
      }
    }
  }

  public function getName() {
    return 'TFetchResultsResp';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->status = new TStatus();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->hasMoreRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->results = new TRowSet();
            $xfer += $this->results->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TFetchResultsResp');
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 1);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hasMoreRows !== null) {
      $xfer += $output->writeFieldBegin('hasMoreRows', TType::BOOL, 2);
      $xfer += $output->writeBool($this->hasMoreRows);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->results !== null) {
      if (!is_object($this->results)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('results', TType::STRUCT, 3);
      $xfer += $this->results->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

$GLOBALS['TCLIService_CONSTANTS']['PRIMITIVE_TYPES'] = array(
    0 => true,
    1 => true,
    2 => true,
    3 => true,
    4 => true,
    5 => true,
    6 => true,
    7 => true,
    8 => true,
    9 => true,
    15 => true,
);

$GLOBALS['TCLIService_CONSTANTS']['COMPLEX_TYPES'] = array(
    10 => true,
    11 => true,
    12 => true,
    13 => true,
    14 => true,
);

$GLOBALS['TCLIService_CONSTANTS']['COLLECTION_TYPES'] = array(
    10 => true,
    11 => true,
);

$GLOBALS['TCLIService_CONSTANTS']['TYPE_NAMES'] = array(
    0 => "BOOLEAN",
    1 => "TINYINT",
    2 => "SMALLINT",
    3 => "INT",
    4 => "BIGINT",
    5 => "FLOAT",
    6 => "DOUBLE",
    7 => "STRING",
    8 => "TIMESTAMP",
    9 => "BINARY",
    10 => "ARRAY",
    11 => "MAP",
    12 => "STRUCT",
    13 => "UNIONTYPE",
    15 => "DECIMAL",
);


